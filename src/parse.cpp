#include "plugin.h"

//////////////////////////
// Parse capability
//////////////////////////

struct sinsp_param {
    uint16_t param_len;
    uint8_t* param_pointer;
};

// Obtain a param from a sinsp event
static inline sinsp_param get_syscall_evt_param(void* evt, uint32_t num_param)
{
    uint32_t dataoffset = 0;
    // pointer to the lengths array inside the event.
    auto len = (uint16_t*)((uint8_t*)evt +
                           sizeof(falcosecurity::_internal::ss_plugin_event));
    for(uint32_t j = 0; j < num_param; j++)
    {
        // sum lengths of the previous params.
        dataoffset += len[j];
    }
    return {.param_len = len[num_param],
            .param_pointer =
            ((uint8_t*)&len
            [((falcosecurity::_internal::ss_plugin_event*)evt)
                            ->nparams]) +
            dataoffset};
}


// We need to parse only the async events produced by this plugin. The async
// events produced by this plugin are injected in the syscall event source,
// so here we need to parse events coming from the "syscall" source.
// We will select specific events to parse through the
// `get_parse_event_types` API.
std::vector<std::string> my_plugin::get_parse_event_sources() {
    return PARSE_EVENT_SOURCES;
}

std::vector<falcosecurity::event_type> my_plugin::get_parse_event_types() {
    return PARSE_EVENT_CODES;
}

bool my_plugin::parse_async_event(
        const falcosecurity::parse_event_input& in) {
    auto& evt = in.get_event_reader();
    falcosecurity::events::asyncevent_e_decoder ad(evt);
    bool added = std::strcmp(ad.get_name(), ASYNC_EVENT_NAME_ADDED) == 0;
    bool removed = std::strcmp(ad.get_name(), ASYNC_EVENT_NAME_REMOVED) == 0;
    if(!added && !removed)
    {
        // We are not interested in parsing async events that are not
        // generated by our plugin.
        // This is not an error, it could happen when we have more than one
        // async plugin loaded.
        SPDLOG_DEBUG("received an sync event with name {}", ad.get_name());
        return true;
    }

    uint32_t json_charbuf_len = 0;
    char* json_charbuf_pointer = (char*)ad.get_data(json_charbuf_len);
    if(json_charbuf_pointer == nullptr)
    {
        m_lasterr = "there is no payload in the async event";
        SPDLOG_ERROR(m_lasterr);
        return false;
    }
    auto json_event = nlohmann::json::parse(std::string(json_charbuf_pointer));

    auto cinfo = container_info::from_json(json_event);
    if (added) {
        m_containers[cinfo.m_id] = cinfo;
    } else {
        m_containers.erase(cinfo.m_id);
    }
    return true;
}

bool my_plugin::parse_container_event(
        const falcosecurity::parse_event_input& in) {
    auto& evt = in.get_event_reader();
    auto id_param = get_syscall_evt_param(evt.get_buf(), 0);
    auto type_param = get_syscall_evt_param(evt.get_buf(), 1);
    auto name_param = get_syscall_evt_param(evt.get_buf(), 2);
    auto image_param = get_syscall_evt_param(evt.get_buf(), 3);

    std::string id = (char*)id_param.param_pointer;
    container_type tp = *((container_type*)type_param.param_pointer);
    std::string name = (char*)name_param.param_pointer;
    std::string image = (char*)image_param.param_pointer;

    auto cinfo = container_info();
    cinfo.m_id = id;
    cinfo.m_type = tp;
    cinfo.m_name = name;
    cinfo.m_image = image;
    m_containers[id] = cinfo;
    return true;
}

bool my_plugin::parse_container_json_event(
        const falcosecurity::parse_event_input& in) {
    auto& evt = in.get_event_reader();
    auto json_param = get_syscall_evt_param(evt.get_buf(), 0);

    std::string json_str = (char *)json_param.param_pointer;
    auto json_event = nlohmann::json::parse(json_str);

    auto cinfo = container_info::from_json(json_event);
    m_containers[cinfo.m_id] = cinfo;
    return true;
}

bool my_plugin::parse_new_process_event(
        const falcosecurity::parse_event_input& in) {
    // get tid
    int64_t thread_id = in.get_event_reader().get_tid();
    if(thread_id <= 0)
    {
        SPDLOG_INFO("unknown thread id for event num '{}' with type '{}'",
                    in.get_event_reader().get_num(),
                    int32_t(in.get_event_reader().get_type()));
        return false;
    }

    // compute container_id from tid->cgroups
    auto& tr = in.get_table_reader();
    auto container_id = compute_container_id_for_thread(thread_id, tr);

    // store container_id
    auto& tw = in.get_table_writer();
    // retrieve the thread entry associated with this thread id
    auto thread_entry = m_threads_table.get_entry(tr, thread_id);
    m_container_id_field.write_value(tw, thread_entry,
                                     (const char*)container_id.c_str());
    return true;
}

bool my_plugin::parse_event(const falcosecurity::parse_event_input& in) {
    // NOTE: today in the libs framework, parsing errors are not logged
    auto& evt = in.get_event_reader();

    switch(evt.get_type())
    {
        case PPME_ASYNCEVENT_E:
            return parse_async_event(in);
        case PPME_CONTAINER_E:
            return parse_container_event(in);
        case PPME_CONTAINER_JSON_E:
        case PPME_CONTAINER_JSON_2_E:
            return parse_container_json_event(in);
        case PPME_SYSCALL_CLONE_20_X:
        case PPME_SYSCALL_FORK_20_X:
        case PPME_SYSCALL_VFORK_20_X:
        case PPME_SYSCALL_CLONE3_X:
            return parse_new_process_event(in);
        default:
            SPDLOG_ERROR("received an unknown event type {}",
                         int32_t(evt.get_type()));
            return false;
    }
}

FALCOSECURITY_PLUGIN_EVENT_PARSING(my_plugin);